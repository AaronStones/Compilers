//
//  Compiler.cpp - PAL Compiler entry point function.
//  PAL Compiler
//
//  Created by Amy Parent on 2017-02-17.
//  Copyright Â© 2017 Amy Parent. All rights reserved.
//
#include <iostream>
#include <cstdlib>
#include <fstream>
#include "common.hpp"
#include "PALScanner.hpp"
#include "PALParser.hpp"

// Prints the usage message and returns the failure error code.
int exitUsage(const char** args) {
    std::cerr << args[0] << ": error: wrong number of arguments" << std::endl;
    std::cerr << "usage: " << args[0] << " infile [outfile]" << std::endl;
    return EXIT_FAILURE;
}

// Prints an error and returns the failure error code.
int exitError(const String& message) {
    std::cerr << "error: " << message << std::endl;
    return EXIT_FAILURE;
}

// 
int main(int argc, const char** args) {
    if(argc < 2 || argc > 3) {
        return exitUsage(args);
    }
    
    // Create the input stream for the source file.
    std::ifstream input{args[1]};
    if(!input.is_open()) {
        return exitError("cannot open '" + String(args[1]) + "' for reading");
    }
    
    // Mimick GCC's behaviour if no output path is specified.
    String outpath = "a.omf";
    if(argc == 3) {
        outpath = args[2];
    }
    
    // Create the scanner
    PALScanner scanner{input};
    PALParser parser{scanner};
    
    if(!parser.invoke()) {
        // If any errors occured during compilation, print them and exit
        for(const auto& error : parser.errors()) {
            std::cerr << *error << std::endl;
        }
        std::cerr << parser.errors().size() << " errors generated" << std::endl;
    } else {
        // No errors. If an output file was specified, open it and write the
        // generated bytecode module to it.
        std::ofstream output{outpath};
        if(!output.is_open()) {
            return exitError("cannot open '" + outpath + "' for reading");
        }
        parser.generator().writeModule(output);
    }
}
